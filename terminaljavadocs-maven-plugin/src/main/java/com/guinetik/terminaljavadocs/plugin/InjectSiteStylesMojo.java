package com.guinetik.terminaljavadocs.plugin;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.StandardCopyOption;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;

/**
 * Injects Terminal Javadocs styling (CSS + JS) into all HTML files
 * generated by the Maven site.
 *
 * <p>
 * This Mojo runs after site generation and:
 * <ul>
 * <li>Copies page-type-specific CSS files to the site directory</li>
 * <li>Recursively scans all HTML files in the site directory</li>
 * <li>Detects page type (coverage, jxr, javadoc, site)</li>
 * <li>Injects the appropriate CSS and JS for each page type</li>
 * <li>Supports nested sites (mono-repo style)</li>
 * </ul>
 *
 * <p>
 * The CSS/JS files are built from the css-zen-garden design system
 * using npm and output to this plugin's resources.
 */
@Mojo(name = "inject-styles", defaultPhase = org.apache.maven.plugins.annotations.LifecyclePhase.POST_SITE)
public class InjectSiteStylesMojo extends AbstractMojo {

    /**
     * Page types with their corresponding CSS files.
     */
    public enum PageType {
        COVERAGE("coverage", "terminaljavadocs-coverage.min.css"),
        JXR("jxr", "terminaljavadocs-jxr.min.css"),
        JAVADOC("javadoc", "terminaljavadocs-javadoc.min.css"),
        SITE("site", "terminaljavadocs-site.min.css");

        private final String name;
        private final String cssFile;

        PageType(String name, String cssFile) {
            this.name = name;
            this.cssFile = cssFile;
        }

        public String getName() {
            return name;
        }

        public String getCssFile() {
            return cssFile;
        }
    }

    /** Resource path prefix for styles */
    private static final String STYLES_RESOURCE_PATH = "styles/";

    /** Resource path for the bundled JS */
    private static final String JS_FILE = "terminaljavadocs.min.js";

    /** Marker to detect already-injected pages */
    private static final String INJECTION_MARKER = "terminal-javadocs-injected";

    @Parameter(defaultValue = "${session}", readonly = true, required = true)
    private MavenSession session;

    @Parameter(defaultValue = "${project}", readonly = true, required = true)
    private MavenProject project;

    @Parameter(property = "terminaljavadocs.skip", defaultValue = "false")
    private boolean skip;

    @Parameter(defaultValue = "${project.build.directory}", readonly = true)
    private File buildDirectory;

    /**
     * Directory name where styles will be copied within the site.
     */
    @Parameter(property = "terminaljavadocs.stylesDir", defaultValue = "terminal-styles")
    private String stylesDir;

    /**
     * Whether to process nested module sites.
     */
    @Parameter(property = "terminaljavadocs.processNestedSites", defaultValue = "true")
    private boolean processNestedSites;

    private int processedFiles = 0;
    private int coverageFiles = 0;
    private int jxrFiles = 0;
    private int javadocFiles = 0;
    private int siteFiles = 0;

    @Override
    public void execute() throws MojoExecutionException {
        if (skip) {
            getLog().info("Skipping style injection");
            return;
        }

        try {
            // Determine the site directory - prefer staging if it exists
            File siteDir = new File(buildDirectory, "staging");
            if (!siteDir.exists()) {
                siteDir = new File(buildDirectory, "site");
            }

            if (!siteDir.exists()) {
                getLog().info("No site directory found, skipping style injection");
                return;
            }

            getLog().info("Injecting Terminal Javadocs styles into site: " + siteDir.getAbsolutePath());

            // Copy style resources to the site directory
            File stylesTargetDir = new File(siteDir, stylesDir);
            copyStyleResources(stylesTargetDir);

            // Process the main site
            processHtmlFiles(siteDir, siteDir);

            // Process nested module sites if enabled
            if (processNestedSites) {
                List<MavenProject> projects = session.getProjects();

                // First, process staged module subdirectories (for site:stage)
                // When using site:stage, modules are aggregated as subdirectories within
                // target/staging
                if (siteDir.getName().equals("staging")) {
                    for (MavenProject reactorProject : projects) {
                        if (reactorProject.equals(project)) {
                            continue; // Skip parent
                        }

                        String artifactId = reactorProject.getArtifactId();
                        File moduleStagedDir = new File(siteDir, artifactId);

                        if (moduleStagedDir.exists() && moduleStagedDir.isDirectory()) {
                            // Copy styles to staged module subdirectory
                            File moduleStylesDir = new File(moduleStagedDir, stylesDir);
                            copyStyleResources(moduleStylesDir);

                            getLog().info("Processing staged module site: " + artifactId);
                            processHtmlFiles(moduleStagedDir, moduleStagedDir);
                        }
                    }
                }

                // Fallback: process individual module site directories (for mvn site without
                // staging)
                for (MavenProject reactorProject : projects) {
                    if (reactorProject.equals(project)) {
                        continue; // Skip parent, already processed
                    }

                    String buildDir = reactorProject.getBuild().getDirectory();

                    // Check staging first, then site
                    File moduleSiteDir = new File(buildDir, "staging");
                    if (!moduleSiteDir.exists()) {
                        moduleSiteDir = new File(buildDir, "site");
                    }

                    if (moduleSiteDir.exists()) {
                        String artifactId = reactorProject.getArtifactId();

                        // Copy styles to module site
                        File moduleStylesDir = new File(moduleSiteDir, stylesDir);
                        copyStyleResources(moduleStylesDir);

                        getLog().info("Processing individual module site: " + artifactId);
                        processHtmlFiles(moduleSiteDir, moduleSiteDir);
                    }
                }
            }

            // Log statistics
            getLog().info("Style injection complete:");
            getLog().info("  Total HTML files processed: " + processedFiles);
            getLog().info("  Coverage pages: " + coverageFiles);
            getLog().info("  JXR pages: " + jxrFiles);
            getLog().info("  Javadoc pages: " + javadocFiles);
            getLog().info("  Site pages: " + siteFiles);

        } catch (IOException e) {
            throw new MojoExecutionException("Failed to inject styles", e);
        }
    }

    /**
     * Copy style resources from the plugin JAR to the target directory.
     */
    private void copyStyleResources(File targetDir) throws IOException {
        targetDir.mkdirs();

        // Copy CSS for each page type
        for (PageType pageType : PageType.values()) {
            copyResource(
                    STYLES_RESOURCE_PATH + pageType.getCssFile(),
                    new File(targetDir, pageType.getCssFile()));
        }

        // Copy JS
        copyResource(STYLES_RESOURCE_PATH + JS_FILE, new File(targetDir, JS_FILE));
    }

    /**
     * Copy a single resource file.
     */
    private void copyResource(String resourcePath, File targetFile) throws IOException {
        try (InputStream is = getResourceStream(resourcePath)) {
            if (is != null) {
                Files.copy(is, targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
                getLog().debug("Copied resource: " + resourcePath + " -> " + targetFile);
            } else {
                getLog().warn("Resource not found: " + resourcePath +
                        ". Run 'npm run build' in css-zen-garden to generate it.");
            }
        }
    }

    /**
     * Get an input stream for a resource, trying multiple classloaders.
     */
    private InputStream getResourceStream(String resourcePath) {
        InputStream is = Thread.currentThread()
                .getContextClassLoader()
                .getResourceAsStream(resourcePath);

        if (is == null) {
            is = InjectSiteStylesMojo.class.getClassLoader().getResourceAsStream(resourcePath);
        }

        if (is == null) {
            is = InjectSiteStylesMojo.class.getResourceAsStream("/" + resourcePath);
        }

        return is;
    }

    /**
     * Process all HTML files in the given directory recursively.
     */
    private void processHtmlFiles(File directory, File siteRoot) throws IOException {
        Files.walkFileTree(directory.toPath(), new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                if (file.toString().endsWith(".html")) {
                    processHtmlFile(file.toFile(), siteRoot);
                }
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
                getLog().warn("Failed to visit file: " + file + " - " + exc.getMessage());
                return FileVisitResult.CONTINUE;
            }
        });
    }

    /**
     * Process a single HTML file - detect its type and inject appropriate styles.
     */
    private void processHtmlFile(File htmlFile, File siteRoot) throws IOException {
        String content = new String(Files.readAllBytes(htmlFile.toPath()), StandardCharsets.UTF_8);

        // Check if styles are already injected (avoid duplicate injection)
        if (content.contains(INJECTION_MARKER)) {
            getLog().debug("Skipping already injected file: " + htmlFile);
            return;
        }

        // Detect page type
        PageType pageType = detectPageType(htmlFile, content);

        // Calculate relative path to styles directory
        String relativePath = calculateRelativePath(htmlFile, siteRoot);

        // Generate the style injection snippet
        String styleSnippet = generateStyleSnippet(pageType, relativePath);

        // Inject styles before </head>
        String modifiedContent = injectStyles(content, styleSnippet);

        if (modifiedContent != null) {
            Files.write(htmlFile.toPath(), modifiedContent.getBytes(StandardCharsets.UTF_8));
            processedFiles++;

            // Update statistics
            switch (pageType) {
                case COVERAGE:
                    coverageFiles++;
                    break;
                case JXR:
                    jxrFiles++;
                    break;
                case JAVADOC:
                    javadocFiles++;
                    break;
                case SITE:
                    siteFiles++;
                    break;
            }

            getLog().debug("Injected " + pageType.getName() + " styles into: " + htmlFile);
        }
    }

    /**
     * Detect the page type based on file path and content.
     */
    private PageType detectPageType(File htmlFile, String content) {
        String path = htmlFile.getAbsolutePath().replace('\\', '/').toLowerCase();

        // Path-based detection (most reliable)
        if (path.contains("/jacoco/") || path.contains("/coverage/")) {
            return PageType.COVERAGE;
        }
        if (path.contains("/xref/") || path.contains("/xref-test/")) {
            return PageType.JXR;
        }
        if (path.contains("/apidocs/") || path.contains("/testapidocs/") || path.contains("/javadoc/")) {
            return PageType.JAVADOC;
        }

        // Content-based detection (fallback)
        if (isJacocoContent(content)) {
            return PageType.COVERAGE;
        }
        if (isJxrContent(content)) {
            return PageType.JXR;
        }
        if (isJavadocContent(content)) {
            return PageType.JAVADOC;
        }

        // Default to site
        return PageType.SITE;
    }

    /**
     * Check if content is from JaCoCo coverage report.
     */
    private boolean isJacocoContent(String content) {
        return content.contains("jacoco") ||
                content.contains("Coverage Report") ||
                content.contains("class=\"el_package\"") ||
                content.contains("class=\"el_class\"") ||
                content.contains("class=\"ctr2\"");
    }

    /**
     * Check if content is from JXR source cross-reference.
     */
    private boolean isJxrContent(String content) {
        return content.contains("jxr") ||
                content.contains("Cross-Reference") ||
                content.contains("class=\"jxr_") ||
                content.contains("id=\"jxr_");
    }

    /**
     * Check if content is from Javadoc.
     */
    private boolean isJavadocContent(String content) {
        return content.contains("Generated by javadoc") ||
                content.contains("<!-- Generated by javadoc") ||
                content.contains("class=\"summary-table\"") ||
                content.contains("class=\"member-signature\"") ||
                content.contains("class=\"description\"");
    }

    /**
     * Calculate relative path from HTML file to site root.
     */
    private String calculateRelativePath(File htmlFile, File siteRoot) {
        Path htmlPath = htmlFile.toPath().getParent();
        Path rootPath = siteRoot.toPath();

        try {
            Path relativePath = htmlPath.relativize(rootPath);
            String result = relativePath.toString().replace('\\', '/');
            if (result.isEmpty()) {
                return "./";
            }
            if (!result.endsWith("/")) {
                result += "/";
            }
            return result;
        } catch (IllegalArgumentException e) {
            // Paths are on different roots, use absolute
            return "./";
        }
    }

    /**
     * Generate the style injection snippet for a page type.
     */
    private String generateStyleSnippet(PageType pageType, String relativePath) {
        String stylesPath = relativePath + stylesDir + "/";

        return "\n<!-- " + INJECTION_MARKER + " [" + pageType.getName() + "] -->\n" +
                "<link rel=\"stylesheet\" href=\"" + stylesPath + pageType.getCssFile() + "\">\n" +
                "<script src=\"" + stylesPath + JS_FILE + "\" defer></script>\n";
    }

    /**
     * Inject styles into HTML content before &lt;/head&gt;.
     */
    private String injectStyles(String content, String styleSnippet) {
        // Try to inject before </head>
        Pattern headPattern = Pattern.compile("(</head>)", Pattern.CASE_INSENSITIVE);
        Matcher matcher = headPattern.matcher(content);

        if (matcher.find()) {
            return content.substring(0, matcher.start()) +
                    styleSnippet +
                    content.substring(matcher.start());
        }

        // If no </head>, try after <head>
        Pattern headOpenPattern = Pattern.compile("(<head[^>]*>)", Pattern.CASE_INSENSITIVE);
        Matcher openMatcher = headOpenPattern.matcher(content);

        if (openMatcher.find()) {
            return content.substring(0, openMatcher.end()) +
                    styleSnippet +
                    content.substring(openMatcher.end());
        }

        // No head section found
        getLog().warn("No <head> section found in HTML, cannot inject styles");
        return null;
    }
}
